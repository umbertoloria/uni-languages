\documentclass[]{article}
\usepackage[utf8]{inputenc}
\usepackage{comment}
\usepackage{mathtools}

\title{Appunti SFB 2023/2024}
\author{Umberto Loria}
\date{Ottobre 2023}

\begin{document}

\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents{}
\newpage
\section{Alfabeti e linguaggi}

Un \textit{alfabeto} \mbox{$\Sigma$} è un insieme \underline{finito} di elementi (lettere, simbolio caratteri).
\\
Sia \mbox{$\Sigma=\{\sigma_0 ... \sigma_k\}$} alfabeto di \begin{math}k\end{math} simboli con cardinalità \mbox{$|\Sigma|=k$}.
\\
\\
Esempi:

\mbox{$\Sigma=\{a, b, ..., z\}$} alfabeto delle lettere romane minuscole

\mbox{$\Sigma=\{0, 1, ..., 9\}$} alfabeto delle cifre arabe

\mbox{$\Sigma=\{0, 1\}$} alfabeto binario
\\
\\
Una \textit{parola} (o stringa) su un alfabeto è una sequenza (finita) di simboli dell'alfabeto.
Esempio: \mbox{$\Sigma = \{a, c, s\}, w = casa$} parola su \mbox{$\Sigma$}
\\
\\
Un \textit{linguaggio} formale è un insieme di parole su un alfabeto.
\\
Esempio:

Insieme di tutti i programmi sintatticamente validi scritti in C++

Insieme di nomi di variabili in Java
\\
\\
La \textit{cardinalità di un linguaggio} finito è il numero di parole che esso contiene.
Esempi:

\mbox{$L_1=\{a, b, ab\}, |L_1|=3$}

\mbox{$L_2=\{aba, abb\}, |L_2|=2$}
\\
\\
Un linguaggio è \textit{finito} se contiene un numero finito di parole.
\\
Un linguaggio è \textit{non finito} se contiene un numero infinito di parole.


\section{Parole}

La lunghezza di una parola \mbox{$w$} è definita con \mbox{$|w|$}. Esempio: \mbox{$|ab| = 2$}.
\\
\\
La parola vuota si indica con \mbox{$\epsilon$}. Essa è l'elemento neutro dell'insieme delle parole ed è l'unica
parola con lunghezza pari a \mbox{$0$}. Quindi vale \mbox{$|\epsilon|=0$}.
\\
\\
Il \textit{numero di occorrenze} del simbolo \mbox{$\sigma$} in una parola \mbox{$w$} è definito con \mbox{$|w|_\sigma$}. Esempio: \mbox{$|aab|_a=2$}.


\subsection{Uguaglianza tra parole}

Sia
\begin{math}
a = a_1...a_k
\end{math}
e
\begin{math}
b = b_1...b_h
\end{math}
con
\begin{math}
k, h \in \mathbf{N},
a_1, ..., a_k, b_1, ..., b_h \in \Sigma
\end{math}.
\\
Allora:
\\
\begin{math}
a=b
\overset{\text{def}}{\Leftrightarrow}
\begin{cases}
k = h \\
\forall i \in \{1, ..., k\} : a_i=b_i
\end{cases}
\end{math}

\newpage
\subsection{Concatenazione di parole}

Sia
\begin{math}
a = a_1...a_k
\end{math}
e
\begin{math}
b = b_1...b_h
\end{math}
con
\begin{math}
k, h \in \mathbf{N},
a_1, ..., a_k, b_1, ..., b_h \in \Sigma
\end{math}.
\\
Allora:
\\
\begin{math}
ab = a_1...a_kb_1...b_h
\end{math}
\\
Questa operazione si chiama concatelazione (o giustapposizione) di parole.
\\
\\
Si noti che \mbox{$\epsilon w = w \epsilon = w$} e che \mbox{$\epsilon \epsilon = \epsilon$}.
\\
\\
L'operazione di concatenazione non gode della proprietà commutativa, infatti con \mbox{$a=anna, b=maria$} si ha
che \mbox{$ab = annamaria \neq mariaanna = ba$}.


\subsubsection{Proprietà associativa della concatenazione}

L'operazione di concatenazione gode invece della proprietà associativa.
Siano \mbox{$a=a_1...a_m, b=b_1...b_n, c=c_1...c_l$} con
\mbox{$a_1, ..., a_m, b_1, ..., b_n, c_1, ..., c_l \in \Sigma, m, n, l \in \mathbf{N}$}
\\
Vale che:
\\
\mbox{$(ab)c = (a_1...a_mb_1...b_n)c_1...c_l = a_1...a_mb_1...b_nc_1...c_l = a_1...a_m(b_1...b_nc_1...c_l) = a(bc)$}


\subsubsection{Stabilità della lunghezza di parole rispetto alla concatenazione}

Siano \mbox{$a=a_1...a_m, b=b_1...b_n$} con
\mbox{$a_1, ..., a_m, b_1, ..., b_n \in \Sigma, m, n \in \mathbf{N}$}
\\
Vale che:
\\
\mbox{$|ab| = |a| + |b| = m + n$}
\\
\\
Dimostrazione diretta:
\\
\mbox{$|ab| = |a_1...a_mb_1...b_n| = |a_1...a_m| + |b_1...b_n| = m + n = |a| + |b|$}
\\
\\
Dimostrazione induttiva:
\\
Passo base:

\mbox{$|ab|=|a_1...a_mb_1...b_n|$}.
\\
Passo induttivo:

Sia
\mbox{$|wv|=|w|+|v|$}
con
\mbox{$w, v \in \Sigma^*, a, b \in \Sigma$}

allora

\mbox{$|wavb| = |wvab| = |wv| + 2 = |w| + |v| + 2 = |w| + |a| + |v| + |b| = |wa| + |vb|$}


\subsection{Prefissi, suffissi e sottostringhe}

Sia \mbox{$x = uyv$} con \mbox{$u, y, z \in \Sigma^*$}, si dicono:

\mbox{$u$} prefisso di \mbox{$x$}

\mbox{$y$} sottostringa di \mbox{$x$}

\mbox{$v$} suffisso di \mbox{$x$}
\\
Una \textit{sottostringa} può essere chiamata anche fattore.
\\
Si noti che vangolo anche le seguenti.

\mbox{$x$} prefisso di \mbox{$x$}

\mbox{$x$} sottostringa di \mbox{$x$}

\mbox{$x$} suffisso di \mbox{$x$}


\subsubsection{Prefissi propri, suffissi propri e sottostringhe proprie}

Siano \mbox{$w, x \in \Sigma^*$}
\\
allora:
\\
\\
\begin{math}
w \text{ prefisso proprio di } x
\overset{\text{def}}{\Leftrightarrow}
\begin{cases}
w \text{ prefisso di } x \\
w \neq x
\end{cases}
\end{math}
\\
\\
\\
\begin{math}
w \text{ sottostringa propria di } x
\overset{\text{def}}{\Leftrightarrow}
\begin{cases}
w \text{ sottostringa di } x \\
w \neq x
\end{cases}
\end{math}
\\
\\
\\
\begin{math}
w \text{ suffisso proprio di } x
\overset{\text{def}}{\Leftrightarrow}
\begin{cases}
w \text{ suffisso di } x \\
w \neq x
\end{cases}
\end{math}


\subsection{Inversa di una parola}

Sia \mbox{$w = w_1...w_k$} con \mbox{$k \in \mathbf{N}$}.
\\
La parola inversa è \mbox{$w^R = w_k...w_1$}
\\
\\
Definizione ricorsiva:
\\
Passo base:
\\
\mbox{$\epsilon^R = \epsilon$}
\\
Passo ricorsivo:
\\
Sia \mbox{$w = x \sigma$} con \mbox{$x \in \Sigma^*, \sigma \in \Sigma$}
\\
\mbox{$w^R = (x \sigma)^R = \sigma w^R$}
\\
\\
La inversione di una parola è talvolta chiamata \textit{riflessione}.
\\
\\
Si noti che:
\\
\mbox{$ (x^R)^R = x $}
\\
Dimostrazione:
\\
\mbox{$ (x^R)^R = ((x_1...x_k)^R)^R = (x_k...x_1)^R = x_1...x_k = x $}
\\
\\
Si noti che:
\\
\mbox{$ (xy)^R = y^R x^R $}
\\
Dimostrazione:
\\
\mbox{$ (xy)^R = (x_1...x_k y_1...y_h)^R = y_h...y_1 x_k...x_1 $}



\subsection{Precedenze delle operazioni}

L'elevamento a potenza di una parola ha precedenza rispetto alla concatenazione.
\\
\mbox{$ (ab)^2 = abab \neq abb = ab^2 $}
\\
L'inversione di una parola ha precedenza rispetto alla concatenazione.
\\
\mbox{$ (ab)^R = ba \neq ab = ab^R $}


\newpage
\section{Automi finiti}

La teoria degli automi nasce negli anni '30 grazie al lavoro di matematici tra cui Turing, Church, Kleene
con l'obiettivo di fornire una formalizzazione matematica alla nozione di algoritmo. Parallelamente, negli
anni '40 il neurofisiologo McCulloch e il matematico Pitts cercarono di dare formalizzazione matematica del
funzionamento di cellule nervose, neuroni o reti di neuroni. La prima esposizione chiara e abbastanza
esauriente della teoria degli automi finiti fu pubblicata da Rabin e Scott nel 1959.
\\
\\
Un automa finito è un modello di computazione dotato di una quantità di memoria estremamente limitata. Lo
si può immaginare come un sistema avente un numero finito di stati possibili e dotato di un \textit{controllo}
che indica uno o più stati ad ogni dato istante. La computazione di un automa finito consiste nel cambiamento
di stati durante la lettura dell'input. L'input di un automa finito è una parola scritta su un nastro, e la
progressiva lettura delle lettere (grazie a una testina che si muove da sinistra verso destra) determina il
potenziale cambiamento di stati della macchina. La computazione di un automa finito in relazione a una
parola in input termina sempre, ma l'esito della computazione può essere quello di accettare o non accettare
la parola in input in funzione dello stato della macchina alla fine della computazione.
\\
\\
Esistono più di un tipo di automa finito. Questo materiale descrive gli \textit{automi finiti deterministici}
e gli \textit{automi finiti non-deterministici}.

\subsection{Automi finiti deterministici}
...


\newpage
\section*{Conclusioni}

...

\end{document}
